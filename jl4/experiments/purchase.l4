

-- MODULE purchaseTemplate

-- a buyer and a seller each need to get their act together, culminating in two synchronized actions:
-- Action 1: buyer sends money to the seller
-- Action 2: seller sends product to the buyer
-- 
-- the Buyer prepares for Action 1 by getting their funds ready.
-- the Seller prepares for Action 2 by getting their product ready.
--
-- These preparation steps are internal to each party, but are exposed here so that we can later
-- (at the assertion level) ask questions like "must I do Prep1 if I want to fulfil my part of the contract?"
--
-- At the planning level, we can abductively reason answers to questions like "what is the latest that I have to do X?"

-- in the future, this would refactor out to a Money library

DECLARE Currency IS ONE OF usd, sgd, hkd, cad, eur

-- be nice if we could have inlined recursive record definitions so the MoneyAmount becomes a lambda
DECLARE MoneyAmount
         HAS  units  IS A NUMBER
              cents  IS A NUMBER
   -- these should be integers, because responsible financial software doesn't use floats for money!

DECLARE  Money
    HAS  currency IS A Currency
         amount IS A MoneyAmount

DECLARE DateMon IS ONE OF jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec

DECLARE  Date
    HAS  year  IS A NUMBER
         mon   IS A DateMon
         day   IS A NUMBER
               -- later we can have a CONSTRAINT over the main datatype if we want to, but let's not get bogged down

DECLARE Entity
    HAS name   IS A STRING
         
-- in future, we should support A DICT OF xxx
-- where the first attribute in the dict declaration is used as the key, indexed using inv's "some title"

DECLARE OPTIONAL a
  IS ONE OF
    Nothing
    Just HAS payload IS AN a

DECLARE InventoryItem
    HAS title   IS A STRING
        count   IS A NUMBER
        expiry  IS AN OPTIONAL Date -- Maybe semantics, with Nothing | Just a, expressed syntactically has "No Date" for Nothing and Date for just

DECLARE  Party -- IS AN Entity -- inherits "name" attribute; this is how we do "extends"
    HAS  name   IS A STRING
         cash   IS A Money -- cash on hand, in wallet
         inv    IS A LIST OF InventoryItem
         
-- actual contract-related data types

DECLARE Deal
    HAS price  IS A Money
        item   IS AN InventoryItem
        buyer  IS A Party
        seller IS A Party

DECLARE OPTIONAL a
  IS ONE OF
    Nothing
    Just HAS payload IS AN a

GIVETH A Deal
myDeal234235 MEANS
  Deal WITH buyer  IS Party WITH name IS "Alice Avocado"
                                 cash IS Money OF usd, MoneyAmount OF 50, 0
                                 inv  IS EMPTY
            seller IS Party WITH name IS "Robert Rich"
                                 cash IS Money OF usd, MoneyAmount OF 50, 0
                                 inv  IS LIST InventoryItem OF "potato",  12,   Nothing
                                              ^             OF "corn",     120, Nothing
                                              ^             OF "avocado",  2,   Nothing -- 2025, 8, 1
            price  IS Money OF usd, MoneyAmount OF 100, 00
            item   IS InventoryItem OF "tomato", 20, Just (Date (2025, aug, 1))

-- ASSUME and DECLARE are semantically the same but the former is autogenerated by a code action while the latter is hand- or AI-coded.
ASSUME Product IS A TYPE

{-
§ purchase template
-- the GIVENs here continue to be in lexical scope until the next top-level section, where the length of the § marker is 1
WITH   deal     IS A Deal -- import the attributes into lexical scope so we don't have to keep saying deal's buyer, deal's price
UPON   bothPartiesReady
PARTY  buyer
MAY    send money (amount = price, to = seller)
BEFORE 30 days -- relative temporal referent: when the UPON first starts to be true
HENCE  -- "external choice" state transition: if we read from the trace that the party takes the action by the deadline, we proceed to new location
       PARTY   seller
       MUST    send item (to = buyer)
       BEFORE  14 days
       HENCE   Fulfilled
       LEST    Breach
LEST   Fulfilled

WHERE
    -- syntax: `X's Y` is akin to a record accessor: x.y, which can be set as mutable state
    DECIDE  bothPartiesReady
        IF  buyer's cash >= price -- we assume that Money is in typeclass Ord and compares at the per-currency level
       AND  seller's ready

§§ seller is ready when they have the required quantity in inventory
-- we could have inlined this in the `bothPartiesReady` binding, but we're breaking it out to illustrate syntax.
-- note that because length("§§") == 2, this stanza enjoys the same bindings as the upper stanza "purchase template"
DECIDE  seller's ready -- this is an ad-hoc method, or a predicate upon the seller instance; it should not be prototype-promoted to a method for the buyer
    IF  CONSIDER seller's inv's item -- we implicitly index into seller's inv which is a DICT using the key field, which is item's title; and we bring it into scope
         MATCHES count >= deal's item's count
             AND    expiry IS NoDate
                 OR expiry >= deal's item's expiry


§ buyer preparation
-- the details of the loan are not fully specified here; the loan process is treated "off to the side" of the main transaction
-- even though the bank as a separate person would get its own swimlane in a BPMN visualization of this situation.
GIVEN  buyer  IS A Party
       bank   IS AN Entity
PARTY  buyer
  MAY  `apply for loan` (with = bank, amount = 2000)
HENCE  PARTY   bank
       MAY     `grant loan` (to = buyer, amount = grantedAmount) -- grantedAmount is unified from reading the event trace
       BEFORE  15 days
       HENCE   PARTY buyer
               MAY   `visit` bank
               HENCE UPDATE  buyer's cash += grantedAmount
       LEST Fulfilled
LEST Fulfilled

ASSUME plant IS AN ACTION
ASSUME `apply for loan` IS AN ACTION
ASSUME `grant loan` IS AN ACTION
ASSUME `visit` IS AN ACTION
-- the parameters to the actions can be typed or left untyped, and left to the operationalizations to worry about

§ seller preparation
-- the seller needs time to grow the product, and that happens over multiple phases as well
GIVEN  seller IS A Party
       item   IS AN InventoryItem
PARTY  seller
  MAY  `plant` (seeds = item's title) -- we don't define this action besides typing it; it is an operational detail for a transpilation target to handle
HENCE  PARTY   seller
       MAY     `water plant`
       AFTER   5 days
       BEFORE  8 days
       HENCE   PARTY seller
               MAY     `apply fertilizer`
               AFTER   7 days
               BEFORE  14 days
               HENCE   PARTY seller
                       MAY     `water plant`
                       AFTER   2 days
                       BEFORE  4 days
                       HENCE   PARTY seller
                               MAY     `harvest`
                               AFTER   14 days
                               BEFORE  28 days
                               HENCE   UPDATE seller's inv's item's count += 60
                                              seller's inv's item's expiry = CURRENT + 16 days

-- we know that the semantics of MUST, MAY, and SHANT, in the context of a regulative rule, allow us to fill in default values for HENCE and LEST.
-- for a MUST  rule, the default value for an omitted LEST is Breach;    the default value for an omitted HENCE is Fulfilled.
-- for a SHANT rule, the default value for an omitted LEST is Breach;    the default value for an omitted HENCE is Fulfilled.
-- for a MAY   rule, the default value for an omitted LEST is Fulfilled; the default value for an omitted HENCE is Fulfilled.


-}