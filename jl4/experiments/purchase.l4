
MODULE purchaseTemplate

-- a buyer and a seller each need to get their act together, culminating in two synchronized actions:
-- Action 1: buyer sends money to the seller
-- Action 2: seller sends product to the buyer
-- 
-- the Buyer prepares for Action 1 by getting their funds ready.
-- the Seller prepares for Action 2 by getting their product ready.
--
-- These preparation steps are internal to each party, but are exposed here so that we can later
-- (at the assertion level) ask questions like "must I do Prep1 if I want to fulfil my part of the contract?"
--
-- At the planning level, we can abductively reason answers to questions like "what is the latest that I have to do X?"

-- in the future, this would refactor out to a Money library

DECLARE  Money
    HAS  currency IS ONE OF usd, sgd, hkd, cad, eur
         amount
            HAS  units  IS An Integer
                 cents  IS AN Integer CONSTRAINT < 100
         -- because responsible financial software doesn't use floats for money!

DECLARE  Date
    HAS  year  IS A Number
         mon   IS ONE OF jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
         day   IS A Number CONSTRAINT >= 1 AND <= 31 -- this doesn't prevent us from having the 30th of feb but it's a stab in the right direction
               -- later we can have a CONSTRAINT over the main datatype if we want to, but let's not get bogged down

DECLARE Entity IS A TYPE
    HAS name   IS A String
         
DECLARE  Party IS AN Entity -- inherits "name" attribute
    HAS  cash   IS A Money -- cash on hand, in wallet
         inv    IS A DICT OF InventoryItem -- the first attribute in the dict declaration is used as the key, indexed using inv's "some title"

DECLARE InventoryItem
    HAS title   IS A String
        count   IS A Number
        expiry  IS AN OPTIONAL Date -- Maybe semantics, with Nothing | Just a, expressed syntactically has "No Date" for Nothing and Date for just

-- actual contract-related data types

DECLARE Deal
    HAS price  IS A Money
        item   IS AN InventoryItem
        buyer  IS A Party
        seller IS A Party

DEFINE MyDeal234235 IS A Deal
   HAS buyer   Party (name "Alice Avocado", cash 50, inv ())
       seller  Party
               HAS   "Robert Rich"   IS THE name
                     10              IS THE cash
                     inv IS
                       InventoryItem   potato,   12,  No Date
                       InventoryItem   corn,     120, No Date
                       InventoryItem   avocado,  2,   Date (2025, 5, 1)
       price   Money (usd, (100, 00))
       item    InventoryItem (tomato, 20, Date (2025, 8, 1))

-- ASSUME and DECLARE are semantically the same but the former is autogenerated by a code action while the latter is hand- or AI-coded.
ASSUME Product IS A TYPE

§ purchase template
-- the GIVENs here continue to be in lexical scope until the next top-level section, where the length of the § marker is 1
WITH   deal     IS A Deal -- import the attributes into lexical scope so we don't have to keep saying deal's buyer, deal's price
UPON   bothPartiesReady
PARTY  buyer
MAY    send money (amount = price, to = seller)
BEFORE 30 days -- relative temporal referent: when the UPON first starts to be true
HENCE  -- "external choice" state transition: if we read from the trace that the party takes the action by the deadline, we proceed to new location
       PARTY   seller
       MUST    send item (to = buyer)
       BEFORE  14 days
       HENCE   Fulfilled
       LEST    Breach
LEST   Fulfilled

WHERE
    -- syntax: `X's Y` is akin to a record accessor: x.y, which can be set as mutable state
    DECIDE  bothPartiesReady
        IF  buyer's cash >= price -- we assume that Money is in typeclass Ord and compares at the per-currency level
       AND  seller's ready

§§ seller is ready when they have the required quantity in inventory
-- we could have inlined this in the `bothPartiesReady` binding, but we're breaking it out to illustrate syntax.
-- note that because length("§§") == 2, this stanza enjoys the same bindings as the upper stanza "purchase template"
DECIDE  seller's ready -- this is an ad-hoc method, or a predicate upon the seller instance; it should not be prototype-promoted to a method for the buyer
    IF  CONSIDER seller's inv's item -- we implicitly index into seller's inv which is a DICT using the key field, which is item's title; and we bring it into scope
         MATCHES count >= deal's item's count
             AND    expiry IS NoDate
                 OR expiry >= deal's item's expiry


§ buyer preparation
-- the details of the loan are not fully specified here; the loan process is treated "off to the side" of the main transaction
-- even though the bank as a separate person would get its own swimlane in a BPMN visualization of this situation.
GIVEN  buyer  IS A Party
       bank   IS AN Entity
PARTY  buyer
  MAY  `apply for loan` (with = bank, amount = 2000)
HENCE  PARTY   bank
       MAY     `grant loan` (to = buyer, amount = grantedAmount) -- grantedAmount is unified from reading the event trace
       BEFORE  15 days
       HENCE   PARTY buyer
               MAY   `visit` bank
               HENCE UPDATE  buyer's cash += grantedAmount
       LEST Fulfilled
LEST Fulfilled

ASSUME plant IS AN ACTION
ASSUME `apply for loan` IS AN ACTION
ASSUME `grant loan` IS AN ACTION
ASSUME `visit` IS AN ACTION
-- the parameters to the actions can be typed or left untyped, and left to the operationalizations to worry about

§ seller preparation
-- the seller needs time to grow the product, and that happens over multiple phases as well
GIVEN  seller IS A Party
       item   IS AN InventoryItem
PARTY  seller
  MAY  `plant` (seeds = item's title) -- we don't define this action besides typing it; it is an operational detail for a transpilation target to handle
HENCE  PARTY   seller
       MAY     `water plant`
       AFTER   5 days
       BEFORE  8 days
       HENCE   PARTY seller
               MAY     `apply fertilizer`
               AFTER   7 days
               BEFORE  14 days
               HENCE   PARTY seller
                       MAY     `water plant`
                       AFTER   2 days
                       BEFORE  4 days
                       HENCE   PARTY seller
                               MAY     `harvest`
                               AFTER   14 days
                               BEFORE  28 days
                               HENCE   UPDATE seller's inv's item's count += 60
                                              seller's inv's item's expiry = CURRENT + 16 days

-- we know that the semantics of MUST, MAY, and SHANT, in the context of a regulative rule, allow us to fill in default values for HENCE and LEST.
-- for a MUST  rule, the default value for an omitted LEST is Breach;    the default value for an omitted HENCE is Fulfilled.
-- for a SHANT rule, the default value for an omitted LEST is Breach;    the default value for an omitted HENCE is Fulfilled.
-- for a MAY   rule, the default value for an omitted LEST is Fulfilled; the default value for an omitted HENCE is Fulfilled.