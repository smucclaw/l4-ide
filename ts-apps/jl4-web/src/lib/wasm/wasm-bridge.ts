/**
 * Low-level WASM bridge for L4 language features.
 *
 * This module handles:
 * - Loading and instantiating the WASM module
 * - Calling exported functions via GHC's JS FFI
 *
 * The WASM module is built from jl4-core using GHC's WASM backend.
 * It exports JavaScript-callable functions using `foreign export javascript`.
 *
 * @see https://ghc.gitlab.haskell.org/ghc/doc/users_guide/wasm.html
 */

/**
 * Interface for the L4 WASM module's JavaScript exports.
 *
 * These correspond to `foreign export javascript` declarations in Haskell.
 * GHC's JS FFI handles marshalling automatically - we pass JS values directly.
 */
export interface L4WasmExports {
  /**
   * WebAssembly memory for the module.
   */
  memory: WebAssembly.Memory

  /**
   * Parse and type-check L4 source code.
   * @param source - L4 source code
   * @returns JSON-encoded array of diagnostics
   */
  l4_check(source: string): Promise<string>

  /**
   * Get hover information at a position.
   * @param source - L4 source code
   * @param line - 0-indexed line number
   * @param column - 0-indexed column number
   * @returns JSON-encoded hover info or "null"
   */
  l4_hover(source: string, line: number, column: number): Promise<string>

  /**
   * Get completion suggestions at a position.
   * @param source - L4 source code
   * @param line - 0-indexed line number
   * @param column - 0-indexed column number
   * @returns JSON-encoded array of completion items
   */
  l4_completions(source: string, line: number, column: number): Promise<string>

  /**
   * Get semantic tokens for syntax highlighting.
   * @param source - L4 source code
   * @returns JSON-encoded semantic tokens
   */
  l4_semantic_tokens(source: string): Promise<string>

  /**
   * Evaluate L4 source code and return #EVAL directive results.
   * @param source - L4 source code with #EVAL directives
   * @returns JSON-encoded evaluation results
   */
  l4_eval(source: string): Promise<string>

  /**
   * Get visualization data for a function declaration.
   * @param source - L4 source code
   * @param uri - Document URI
   * @param version - Document version (optional, defaults to 0)
   * @returns JSON-encoded RenderAsLadderInfo or "null" if no visualizable function found
   */
  l4_visualize?(source: string, uri: string, version: number): Promise<string>

  /**
   * Initialize the WASI reactor (and Haskell RTS).
   * Must be called before any other exported functions.
   */
  _initialize(): void

  /**
   * RTS scheduler loop - called by the JS FFI runtime.
   */
  rts_schedulerLoop(): void

  /**
   * Free a stable pointer.
   */
  rts_freeStablePtr(sp: number): void
}

/**
 * Type for the JS FFI imports generator function.
 * This is the default export from the post-link.mjs generated file.
 */
type JsFFIImportsGenerator = (exports: L4WasmExports) => Record<string, unknown>

/**
 * L4 WASM Bridge
 *
 * Provides a high-level interface to the L4 WASM module.
 * Handles loading, caching, and provides typed wrappers around exports.
 */
export class L4WasmBridge {
  private exports: L4WasmExports | null = null

  constructor(
    private wasmUrl: string,
    private jsUrl: string,
    private version: string
  ) {}

  /**
   * Initialize the WASM module
   */
  async initialize(): Promise<void> {
    this.exports = await this.loadModule()

    // Initialize the WASI reactor (and Haskell RTS)
    // This must be called before any other exported functions
    console.log('[L4 WASM] Initializing RTS...')
    this.exports._initialize()
    console.log('[L4 WASM] Module initialized')
  }

  /**
   * Load WASM module with GHC JS FFI support.
   *
   * GHC WASM modules require a two-phase instantiation:
   * 1. Load the JS FFI glue code (generated by post-link.mjs)
   * 2. Instantiate WASM with the JS FFI imports
   */
  private async loadModule(): Promise<L4WasmExports> {
    const cacheKey = `l4-wasm-${this.version}`

    // Load the JS FFI glue code
    console.log(`[L4 WASM] Loading JS FFI: ${this.jsUrl}`)
    const jsModule = await import(/* @vite-ignore */ this.jsUrl)
    const generateImports: JsFFIImportsGenerator = jsModule.default

    // Try cache first for WASM
    let wasmBuffer: ArrayBuffer | null = null
    try {
      const cache = await caches.open('l4-wasm-cache-v1')
      const cached = await cache.match(cacheKey)

      if (cached) {
        console.log(`[L4 WASM] Loading from cache: ${cacheKey}`)
        wasmBuffer = await cached.arrayBuffer()
      }
    } catch (e) {
      console.warn('[L4 WASM] Cache not available:', e)
    }

    // Fetch fresh if not cached
    if (!wasmBuffer) {
      console.log(`[L4 WASM] Fetching: ${this.wasmUrl}`)
      const response = await fetch(this.wasmUrl)

      if (!response.ok) {
        throw new Error(
          `Failed to fetch WASM: ${response.status} ${response.statusText}`
        )
      }

      wasmBuffer = await response.arrayBuffer()

      // Cache for future use
      try {
        const cache = await caches.open('l4-wasm-cache-v1')
        await cache.put(cacheKey, new Response(wasmBuffer.slice(0)))
        console.log(`[L4 WASM] Cached: ${cacheKey}`)
      } catch (e) {
        console.warn('[L4 WASM] Failed to cache:', e)
      }
    }

    // Compile the WASM module
    const wasmModule = await WebAssembly.compile(wasmBuffer)

    // Create a placeholder exports object for the JS FFI generator
    // We'll update it after instantiation
    const exportsProxy: L4WasmExports = {} as L4WasmExports

    // Generate JS FFI imports - these need access to the exports
    // for things like memory access and RTS callbacks
    const jsFFIImports = generateImports(exportsProxy)

    // WASI imports (minimal - just what the RTS needs)
    const wasiImports = this.createWasiImports()

    // Instantiate with all imports
    const instance = await WebAssembly.instantiate(wasmModule, {
      wasi_snapshot_preview1: wasiImports as WebAssembly.ModuleImports,
      ghc_wasm_jsffi: jsFFIImports as WebAssembly.ModuleImports,
    })

    // Copy exports to the proxy object so JS FFI callbacks work
    Object.assign(exportsProxy, instance.exports)

    return instance.exports as unknown as L4WasmExports
  }

  /**
   * Create WASI imports for the GHC RTS.
   * GHC WASM with WASI requires these functions for proper operation.
   *
   * Note: We use WebAssembly.ImportValue compatible signatures.
   * The actual WASI functions receive numbers/bigints from WASM.
   */
  private createWasiImports(): Record<string, WebAssembly.ImportValue> {
    // Helper to get memory (proxy is updated after instantiation)
    const getMemory = () => this.exports?.memory

    // Clock functions
    const clock_time_get = (
      _clockId: number,
      _precision: bigint,
      out: number
    ): number => {
      const memory = getMemory()
      if (memory) {
        const view = new DataView(memory.buffer)
        view.setBigUint64(out, BigInt(Date.now()) * BigInt(1_000_000), true)
      }
      return 0
    }

    // FD operations
    const fd_write = (
      fd: number,
      iovs: number,
      iovsLen: number,
      nwritten: number
    ): number => {
      const memory = getMemory()
      if (memory && (fd === 1 || fd === 2)) {
        const view = new DataView(memory.buffer)
        let totalWritten = 0
        for (let i = 0; i < iovsLen; i++) {
          const ptr = view.getUint32(iovs + i * 8, true)
          const len = view.getUint32(iovs + i * 8 + 4, true)
          const bytes = new Uint8Array(memory.buffer, ptr, len)
          const text = new TextDecoder().decode(bytes)
          if (text.trim()) {
            if (fd === 1) console.log('[WASM stdout]', text)
            else console.error('[WASM stderr]', text)
          }
          totalWritten += len
        }
        view.setUint32(nwritten, totalWritten, true)
      }
      return 0
    }

    const proc_exit = (code: number): void => {
      console.warn('[WASM] proc_exit called with code:', code)
    }

    const args_sizes_get = (argc: number, argvBufSize: number): number => {
      const memory = getMemory()
      if (memory) {
        const view = new DataView(memory.buffer)
        view.setUint32(argc, 0, true)
        view.setUint32(argvBufSize, 0, true)
      }
      return 0
    }

    const environ_sizes_get = (
      environc: number,
      environBufSize: number
    ): number => {
      const memory = getMemory()
      if (memory) {
        const view = new DataView(memory.buffer)
        view.setUint32(environc, 0, true)
        view.setUint32(environBufSize, 0, true)
      }
      return 0
    }

    return {
      clock_time_get,
      fd_write,
      fd_read: () => 0,
      fd_close: () => 0,
      fd_seek: () => 0,
      fd_fdstat_get: () => 0,
      fd_fdstat_set_flags: () => 0,
      fd_filestat_get: () => 0,
      fd_filestat_set_size: () => 0,
      fd_prestat_get: () => 8, // EBADF - no preopened directories
      fd_prestat_dir_name: () => 8, // EBADF
      // Path operations (stubs - not used in reactor mode)
      path_create_directory: () => 63, // ENOSYS
      path_filestat_get: () => 63,
      path_open: () => 63,
      // Polling (stub for async I/O)
      poll_oneoff: () => 0,
      proc_exit,
      args_sizes_get,
      args_get: () => 0,
      environ_sizes_get,
      environ_get: () => 0,
    }
  }

  /**
   * Check if initialized
   */
  isReady(): boolean {
    return this.exports !== null
  }

  /**
   * Parse and type-check source code
   */
  async check(source: string): Promise<Diagnostic[]> {
    if (!this.exports) {
      throw new Error('WASM not initialized')
    }
    const json = await this.exports.l4_check(source)
    return JSON.parse(json)
  }

  /**
   * Get hover information at a position
   */
  async hover(
    source: string,
    line: number,
    character: number
  ): Promise<Hover | null> {
    if (!this.exports) {
      throw new Error('WASM not initialized')
    }
    const json = await this.exports.l4_hover(source, line, character)
    return JSON.parse(json)
  }

  /**
   * Get completions at a position
   */
  async completions(
    source: string,
    line: number,
    character: number
  ): Promise<CompletionItem[]> {
    if (!this.exports) {
      throw new Error('WASM not initialized')
    }
    const json = await this.exports.l4_completions(source, line, character)
    return JSON.parse(json)
  }

  /**
   * Get semantic tokens
   */
  async semanticTokens(source: string): Promise<SemanticTokens> {
    if (!this.exports) {
      throw new Error('WASM not initialized')
    }
    const json = await this.exports.l4_semantic_tokens(source)
    return JSON.parse(json)
  }

  /**
   * Evaluate L4 source code
   */
  async evaluate(source: string): Promise<EvalResult> {
    if (!this.exports) {
      throw new Error('WASM not initialized')
    }
    const json = await this.exports.l4_eval(source)
    return JSON.parse(json)
  }

  /**
   * Get visualization data for ladder diagram.
   * Returns the RenderAsLadderInfo structure needed by the visualizer.
   */
  async visualize(
    source: string,
    uri: string,
    version: number = 0
  ): Promise<unknown | null> {
    if (!this.exports) {
      throw new Error('WASM not initialized')
    }
    // Check if the WASM module supports visualization
    if (!this.exports.l4_visualize) {
      console.warn(
        '[L4 WASM] Visualization not supported - l4_visualize export not available'
      )
      return null
    }
    const json = await this.exports.l4_visualize(source, uri, version)
    return JSON.parse(json)
  }

  /**
   * Check if visualization is supported by this WASM module
   */
  supportsVisualization(): boolean {
    return this.exports?.l4_visualize !== undefined
  }

  /**
   * Clean up resources
   */
  dispose(): void {
    this.exports = null
  }
}

// LSP-compatible types

export interface Position {
  line: number
  character: number
}

export interface Range {
  start: Position
  end: Position
}

export interface Diagnostic {
  range: Range
  severity: number // 1=Error, 2=Warning, 3=Info, 4=Hint
  message: string
  source: string
}

export interface Hover {
  contents: {
    kind: 'markdown' | 'plaintext'
    value: string
  }
  range?: Range
}

export interface CompletionItem {
  label: string
  kind: number // CompletionItemKind
  detail?: string
  documentation?: string
  insertText?: string
}

export interface SemanticTokens {
  data: number[] // Delta-encoded token data
}

export interface EvalResultSuccess {
  success: true
  results: EvalDirectiveResult[]
}

export interface EvalResultFailure {
  success: false
  diagnostics: Diagnostic[]
}

export type EvalResult = EvalResultSuccess | EvalResultFailure

export interface EvalDirectiveResult {
  result: string
  success: boolean
  range?: Range
}
